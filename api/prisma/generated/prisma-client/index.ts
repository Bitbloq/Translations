// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  literal: (where?: LiteralWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  translation: (where?: TranslationWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  language: (where: LanguageWhereUniqueInput) => LanguageNullablePromise;
  languages: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Language>;
  languagesConnection: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LanguageConnectionPromise;
  literal: (where: LiteralWhereUniqueInput) => LiteralNullablePromise;
  literals: (args?: {
    where?: LiteralWhereInput;
    orderBy?: LiteralOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Literal>;
  literalsConnection: (args?: {
    where?: LiteralWhereInput;
    orderBy?: LiteralOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LiteralConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  translation: (
    where: TranslationWhereUniqueInput
  ) => TranslationNullablePromise;
  translations: (args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Translation>;
  translationsConnection: (args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TranslationConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateLanguage: (args: {
    data: LanguageUpdateInput;
    where: LanguageWhereUniqueInput;
  }) => LanguagePromise;
  updateManyLanguages: (args: {
    data: LanguageUpdateManyMutationInput;
    where?: LanguageWhereInput;
  }) => BatchPayloadPromise;
  upsertLanguage: (args: {
    where: LanguageWhereUniqueInput;
    create: LanguageCreateInput;
    update: LanguageUpdateInput;
  }) => LanguagePromise;
  deleteLanguage: (where: LanguageWhereUniqueInput) => LanguagePromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createLiteral: (data: LiteralCreateInput) => LiteralPromise;
  updateLiteral: (args: {
    data: LiteralUpdateInput;
    where: LiteralWhereUniqueInput;
  }) => LiteralPromise;
  updateManyLiterals: (args: {
    data: LiteralUpdateManyMutationInput;
    where?: LiteralWhereInput;
  }) => BatchPayloadPromise;
  upsertLiteral: (args: {
    where: LiteralWhereUniqueInput;
    create: LiteralCreateInput;
    update: LiteralUpdateInput;
  }) => LiteralPromise;
  deleteLiteral: (where: LiteralWhereUniqueInput) => LiteralPromise;
  deleteManyLiterals: (where?: LiteralWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createTranslation: (data: TranslationCreateInput) => TranslationPromise;
  updateTranslation: (args: {
    data: TranslationUpdateInput;
    where: TranslationWhereUniqueInput;
  }) => TranslationPromise;
  updateManyTranslations: (args: {
    data: TranslationUpdateManyMutationInput;
    where?: TranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertTranslation: (args: {
    where: TranslationWhereUniqueInput;
    create: TranslationCreateInput;
    update: TranslationUpdateInput;
  }) => TranslationPromise;
  deleteTranslation: (where: TranslationWhereUniqueInput) => TranslationPromise;
  deleteManyTranslations: (
    where?: TranslationWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  literal: (
    where?: LiteralSubscriptionWhereInput
  ) => LiteralSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  translation: (
    where?: TranslationSubscriptionWhereInput
  ) => TranslationSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "admin_ASC"
  | "admin_DESC";

export type LanguageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "iso_ASC"
  | "iso_DESC"
  | "code_ASC"
  | "code_DESC";

export type TranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "translation_ASC"
  | "translation_DESC";

export type LiteralOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "literal_ASC"
  | "literal_DESC"
  | "as_in_ASC"
  | "as_in_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface LiteralUpdateWithoutTranslationsDataInput {
  project?: Maybe<ProjectUpdateOneRequiredWithoutLiteralsInput>;
  literal?: Maybe<String>;
  as_in?: Maybe<String>;
}

export type LanguageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  iso?: Maybe<String>;
}>;

export interface LanguageUpdateWithWhereUniqueWithoutProjectsInput {
  where: LanguageWhereUniqueInput;
  data: LanguageUpdateWithoutProjectsDataInput;
}

export interface TranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  language?: Maybe<LanguageWhereInput>;
  literal?: Maybe<LiteralWhereInput>;
  project?: Maybe<ProjectWhereInput>;
  translation?: Maybe<String>;
  translation_not?: Maybe<String>;
  translation_in?: Maybe<String[] | String>;
  translation_not_in?: Maybe<String[] | String>;
  translation_lt?: Maybe<String>;
  translation_lte?: Maybe<String>;
  translation_gt?: Maybe<String>;
  translation_gte?: Maybe<String>;
  translation_contains?: Maybe<String>;
  translation_not_contains?: Maybe<String>;
  translation_starts_with?: Maybe<String>;
  translation_not_starts_with?: Maybe<String>;
  translation_ends_with?: Maybe<String>;
  translation_not_ends_with?: Maybe<String>;
  AND?: Maybe<TranslationWhereInput[] | TranslationWhereInput>;
  OR?: Maybe<TranslationWhereInput[] | TranslationWhereInput>;
  NOT?: Maybe<TranslationWhereInput[] | TranslationWhereInput>;
}

export interface LanguageUpdateWithoutProjectsDataInput {
  name?: Maybe<String>;
  iso?: Maybe<String>;
  code?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutLanguagesInput>;
  translations?: Maybe<TranslationUpdateManyWithoutLanguageInput>;
}

export interface LanguageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  iso?: Maybe<String>;
  iso_not?: Maybe<String>;
  iso_in?: Maybe<String[] | String>;
  iso_not_in?: Maybe<String[] | String>;
  iso_lt?: Maybe<String>;
  iso_lte?: Maybe<String>;
  iso_gt?: Maybe<String>;
  iso_gte?: Maybe<String>;
  iso_contains?: Maybe<String>;
  iso_not_contains?: Maybe<String>;
  iso_starts_with?: Maybe<String>;
  iso_not_starts_with?: Maybe<String>;
  iso_ends_with?: Maybe<String>;
  iso_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  projects_every?: Maybe<ProjectWhereInput>;
  projects_some?: Maybe<ProjectWhereInput>;
  projects_none?: Maybe<ProjectWhereInput>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  translations_every?: Maybe<TranslationWhereInput>;
  translations_some?: Maybe<TranslationWhereInput>;
  translations_none?: Maybe<TranslationWhereInput>;
  AND?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  OR?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  NOT?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
}

export interface ProjectUpdateWithWhereUniqueWithoutLanguagesInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutLanguagesDataInput;
}

export interface ProjectUpsertWithoutLiteralsInput {
  update: ProjectUpdateWithoutLiteralsDataInput;
  create: ProjectCreateWithoutLiteralsInput;
}

export interface ProjectUpdateWithoutLanguagesDataInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationUpdateManyWithoutProjectInput>;
  literals?: Maybe<LiteralUpdateManyWithoutProjectInput>;
}

export interface UserUpdateManyWithoutLanguagesInput {
  create?: Maybe<
    UserCreateWithoutLanguagesInput[] | UserCreateWithoutLanguagesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLanguagesInput[]
    | UserUpdateWithWhereUniqueWithoutLanguagesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLanguagesInput[]
    | UserUpsertWithWhereUniqueWithoutLanguagesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateManyWithoutProjectsInput {
  create?: Maybe<
    UserCreateWithoutProjectsInput[] | UserCreateWithoutProjectsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutProjectsInput[]
    | UserUpdateWithWhereUniqueWithoutProjectsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutProjectsInput[]
    | UserUpsertWithWhereUniqueWithoutProjectsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  admin?: Maybe<Boolean>;
  admin_not?: Maybe<Boolean>;
  projects_every?: Maybe<ProjectWhereInput>;
  projects_some?: Maybe<ProjectWhereInput>;
  projects_none?: Maybe<ProjectWhereInput>;
  languages_every?: Maybe<LanguageWhereInput>;
  languages_some?: Maybe<LanguageWhereInput>;
  languages_none?: Maybe<LanguageWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserUpdateWithWhereUniqueWithoutProjectsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutProjectsDataInput;
}

export interface TranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TranslationWhereInput>;
  AND?: Maybe<
    TranslationSubscriptionWhereInput[] | TranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    TranslationSubscriptionWhereInput[] | TranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TranslationSubscriptionWhereInput[] | TranslationSubscriptionWhereInput
  >;
}

export interface UserUpdateWithoutProjectsDataInput {
  name?: Maybe<String>;
  admin?: Maybe<Boolean>;
  languages?: Maybe<LanguageUpdateManyWithoutUsersInput>;
}

export interface LiteralSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LiteralWhereInput>;
  AND?: Maybe<LiteralSubscriptionWhereInput[] | LiteralSubscriptionWhereInput>;
  OR?: Maybe<LiteralSubscriptionWhereInput[] | LiteralSubscriptionWhereInput>;
  NOT?: Maybe<LiteralSubscriptionWhereInput[] | LiteralSubscriptionWhereInput>;
}

export interface LanguageUpdateManyWithoutUsersInput {
  create?: Maybe<
    LanguageCreateWithoutUsersInput[] | LanguageCreateWithoutUsersInput
  >;
  delete?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  connect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  set?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  disconnect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  update?: Maybe<
    | LanguageUpdateWithWhereUniqueWithoutUsersInput[]
    | LanguageUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | LanguageUpsertWithWhereUniqueWithoutUsersInput[]
    | LanguageUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  updateMany?: Maybe<
    | LanguageUpdateManyWithWhereNestedInput[]
    | LanguageUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  admin?: Maybe<Boolean>;
}

export interface LanguageUpdateWithWhereUniqueWithoutUsersInput {
  where: LanguageWhereUniqueInput;
  data: LanguageUpdateWithoutUsersDataInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  admin?: Maybe<Boolean>;
  projects?: Maybe<ProjectCreateManyWithoutUsersInput>;
  languages?: Maybe<LanguageCreateManyWithoutUsersInput>;
}

export interface LanguageUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  iso?: Maybe<String>;
  code?: Maybe<String>;
  projects?: Maybe<ProjectUpdateManyWithoutLanguagesInput>;
  translations?: Maybe<TranslationUpdateManyWithoutLanguageInput>;
}

export interface TranslationUpdateManyMutationInput {
  translation?: Maybe<String>;
}

export interface TranslationUpdateManyWithoutLanguageInput {
  create?: Maybe<
    | TranslationCreateWithoutLanguageInput[]
    | TranslationCreateWithoutLanguageInput
  >;
  delete?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
  connect?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
  set?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
  disconnect?: Maybe<
    TranslationWhereUniqueInput[] | TranslationWhereUniqueInput
  >;
  update?: Maybe<
    | TranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    | TranslationUpdateWithWhereUniqueWithoutLanguageInput
  >;
  upsert?: Maybe<
    | TranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    | TranslationUpsertWithWhereUniqueWithoutLanguageInput
  >;
  deleteMany?: Maybe<
    TranslationScalarWhereInput[] | TranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | TranslationUpdateManyWithWhereNestedInput[]
    | TranslationUpdateManyWithWhereNestedInput
  >;
}

export interface TranslationCreateInput {
  id?: Maybe<ID_Input>;
  language: LanguageCreateOneWithoutTranslationsInput;
  literal: LiteralCreateOneWithoutTranslationsInput;
  project: ProjectCreateOneWithoutTranslationsInput;
  translation: String;
}

export interface TranslationUpdateWithWhereUniqueWithoutLanguageInput {
  where: TranslationWhereUniqueInput;
  data: TranslationUpdateWithoutLanguageDataInput;
}

export interface ProjectUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TranslationUpdateWithoutLanguageDataInput {
  literal?: Maybe<LiteralUpdateOneRequiredWithoutTranslationsInput>;
  project?: Maybe<ProjectUpdateOneRequiredWithoutTranslationsInput>;
  translation?: Maybe<String>;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  users?: Maybe<UserCreateManyWithoutProjectsInput>;
  languages?: Maybe<LanguageCreateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationCreateManyWithoutProjectInput>;
  literals?: Maybe<LiteralCreateManyWithoutProjectInput>;
}

export interface LiteralUpdateOneRequiredWithoutTranslationsInput {
  create?: Maybe<LiteralCreateWithoutTranslationsInput>;
  update?: Maybe<LiteralUpdateWithoutTranslationsDataInput>;
  upsert?: Maybe<LiteralUpsertWithoutTranslationsInput>;
  connect?: Maybe<LiteralWhereUniqueInput>;
}

export interface LiteralUpdateManyMutationInput {
  literal?: Maybe<String>;
  as_in?: Maybe<String>;
}

export interface LanguageUpsertWithWhereUniqueWithoutUsersInput {
  where: LanguageWhereUniqueInput;
  update: LanguageUpdateWithoutUsersDataInput;
  create: LanguageCreateWithoutUsersInput;
}

export interface LiteralCreateInput {
  id?: Maybe<ID_Input>;
  project: ProjectCreateOneWithoutLiteralsInput;
  translations: TranslationCreateOneWithoutLiteralInput;
  literal: String;
  as_in: String;
}

export interface ProjectUpdateOneRequiredWithoutLiteralsInput {
  create?: Maybe<ProjectCreateWithoutLiteralsInput>;
  update?: Maybe<ProjectUpdateWithoutLiteralsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutLiteralsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface LanguageUpdateManyMutationInput {
  name?: Maybe<String>;
  iso?: Maybe<String>;
  code?: Maybe<String>;
}

export interface ProjectUpdateWithoutLiteralsDataInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutProjectsInput>;
  languages?: Maybe<LanguageUpdateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationUpdateManyWithoutProjectInput>;
}

export interface UserUpsertWithWhereUniqueWithoutProjectsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutProjectsDataInput;
  create: UserCreateWithoutProjectsInput;
}

export interface LanguageUpdateManyWithoutProjectsInput {
  create?: Maybe<
    LanguageCreateWithoutProjectsInput[] | LanguageCreateWithoutProjectsInput
  >;
  delete?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  connect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  set?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  disconnect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  update?: Maybe<
    | LanguageUpdateWithWhereUniqueWithoutProjectsInput[]
    | LanguageUpdateWithWhereUniqueWithoutProjectsInput
  >;
  upsert?: Maybe<
    | LanguageUpsertWithWhereUniqueWithoutProjectsInput[]
    | LanguageUpsertWithWhereUniqueWithoutProjectsInput
  >;
  deleteMany?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  updateMany?: Maybe<
    | LanguageUpdateManyWithWhereNestedInput[]
    | LanguageUpdateManyWithWhereNestedInput
  >;
}

export interface LanguageCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  iso: String;
  code: String;
  projects?: Maybe<ProjectCreateManyWithoutLanguagesInput>;
  users?: Maybe<UserCreateManyWithoutLanguagesInput>;
  translations?: Maybe<TranslationCreateManyWithoutLanguageInput>;
}

export interface LiteralWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project?: Maybe<ProjectWhereInput>;
  translations?: Maybe<TranslationWhereInput>;
  literal?: Maybe<String>;
  literal_not?: Maybe<String>;
  literal_in?: Maybe<String[] | String>;
  literal_not_in?: Maybe<String[] | String>;
  literal_lt?: Maybe<String>;
  literal_lte?: Maybe<String>;
  literal_gt?: Maybe<String>;
  literal_gte?: Maybe<String>;
  literal_contains?: Maybe<String>;
  literal_not_contains?: Maybe<String>;
  literal_starts_with?: Maybe<String>;
  literal_not_starts_with?: Maybe<String>;
  literal_ends_with?: Maybe<String>;
  literal_not_ends_with?: Maybe<String>;
  as_in?: Maybe<String>;
  as_in_not?: Maybe<String>;
  as_in_in?: Maybe<String[] | String>;
  as_in_not_in?: Maybe<String[] | String>;
  as_in_lt?: Maybe<String>;
  as_in_lte?: Maybe<String>;
  as_in_gt?: Maybe<String>;
  as_in_gte?: Maybe<String>;
  as_in_contains?: Maybe<String>;
  as_in_not_contains?: Maybe<String>;
  as_in_starts_with?: Maybe<String>;
  as_in_not_starts_with?: Maybe<String>;
  as_in_ends_with?: Maybe<String>;
  as_in_not_ends_with?: Maybe<String>;
  AND?: Maybe<LiteralWhereInput[] | LiteralWhereInput>;
  OR?: Maybe<LiteralWhereInput[] | LiteralWhereInput>;
  NOT?: Maybe<LiteralWhereInput[] | LiteralWhereInput>;
}

export interface ProjectCreateWithoutLanguagesInput {
  id?: Maybe<ID_Input>;
  name: String;
  users?: Maybe<UserCreateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationCreateManyWithoutProjectInput>;
  literals?: Maybe<LiteralCreateManyWithoutProjectInput>;
}

export interface TranslationUpsertWithWhereUniqueWithoutLanguageInput {
  where: TranslationWhereUniqueInput;
  update: TranslationUpdateWithoutLanguageDataInput;
  create: TranslationCreateWithoutLanguageInput;
}

export interface UserCreateWithoutProjectsInput {
  id?: Maybe<ID_Input>;
  name: String;
  admin?: Maybe<Boolean>;
  languages?: Maybe<LanguageCreateManyWithoutUsersInput>;
}

export interface LiteralUpsertWithoutTranslationsInput {
  update: LiteralUpdateWithoutTranslationsDataInput;
  create: LiteralCreateWithoutTranslationsInput;
}

export interface LanguageCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name: String;
  iso: String;
  code: String;
  projects?: Maybe<ProjectCreateManyWithoutLanguagesInput>;
  translations?: Maybe<TranslationCreateManyWithoutLanguageInput>;
}

export interface UserUpdateWithWhereUniqueWithoutLanguagesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLanguagesDataInput;
}

export interface TranslationCreateWithoutLanguageInput {
  id?: Maybe<ID_Input>;
  literal: LiteralCreateOneWithoutTranslationsInput;
  project: ProjectCreateOneWithoutTranslationsInput;
  translation: String;
}

export interface UserUpdateWithoutLanguagesDataInput {
  name?: Maybe<String>;
  admin?: Maybe<Boolean>;
  projects?: Maybe<ProjectUpdateManyWithoutUsersInput>;
}

export interface LiteralCreateWithoutTranslationsInput {
  id?: Maybe<ID_Input>;
  project: ProjectCreateOneWithoutLiteralsInput;
  literal: String;
  as_in: String;
}

export interface ProjectUpdateManyWithoutUsersInput {
  create?: Maybe<
    ProjectCreateWithoutUsersInput[] | ProjectCreateWithoutUsersInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutUsersInput[]
    | ProjectUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutUsersInput[]
    | ProjectUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectCreateWithoutLiteralsInput {
  id?: Maybe<ID_Input>;
  name: String;
  users?: Maybe<UserCreateManyWithoutProjectsInput>;
  languages?: Maybe<LanguageCreateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationCreateManyWithoutProjectInput>;
}

export interface ProjectUpdateWithWhereUniqueWithoutUsersInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutUsersDataInput;
}

export interface LanguageCreateWithoutProjectsInput {
  id?: Maybe<ID_Input>;
  name: String;
  iso: String;
  code: String;
  users?: Maybe<UserCreateManyWithoutLanguagesInput>;
  translations?: Maybe<TranslationCreateManyWithoutLanguageInput>;
}

export interface ProjectUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  languages?: Maybe<LanguageUpdateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationUpdateManyWithoutProjectInput>;
  literals?: Maybe<LiteralUpdateManyWithoutProjectInput>;
}

export interface UserCreateWithoutLanguagesInput {
  id?: Maybe<ID_Input>;
  name: String;
  admin?: Maybe<Boolean>;
  projects?: Maybe<ProjectCreateManyWithoutUsersInput>;
}

export interface TranslationUpdateManyWithoutProjectInput {
  create?: Maybe<
    | TranslationCreateWithoutProjectInput[]
    | TranslationCreateWithoutProjectInput
  >;
  delete?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
  connect?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
  set?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
  disconnect?: Maybe<
    TranslationWhereUniqueInput[] | TranslationWhereUniqueInput
  >;
  update?: Maybe<
    | TranslationUpdateWithWhereUniqueWithoutProjectInput[]
    | TranslationUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | TranslationUpsertWithWhereUniqueWithoutProjectInput[]
    | TranslationUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<
    TranslationScalarWhereInput[] | TranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | TranslationUpdateManyWithWhereNestedInput[]
    | TranslationUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name: String;
  languages?: Maybe<LanguageCreateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationCreateManyWithoutProjectInput>;
  literals?: Maybe<LiteralCreateManyWithoutProjectInput>;
}

export interface TranslationUpdateWithWhereUniqueWithoutProjectInput {
  where: TranslationWhereUniqueInput;
  data: TranslationUpdateWithoutProjectDataInput;
}

export interface TranslationCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  language: LanguageCreateOneWithoutTranslationsInput;
  literal: LiteralCreateOneWithoutTranslationsInput;
  translation: String;
}

export interface TranslationUpdateWithoutProjectDataInput {
  language?: Maybe<LanguageUpdateOneRequiredWithoutTranslationsInput>;
  literal?: Maybe<LiteralUpdateOneRequiredWithoutTranslationsInput>;
  translation?: Maybe<String>;
}

export interface LanguageCreateWithoutTranslationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  iso: String;
  code: String;
  projects?: Maybe<ProjectCreateManyWithoutLanguagesInput>;
  users?: Maybe<UserCreateManyWithoutLanguagesInput>;
}

export interface LanguageUpdateOneRequiredWithoutTranslationsInput {
  create?: Maybe<LanguageCreateWithoutTranslationsInput>;
  update?: Maybe<LanguageUpdateWithoutTranslationsDataInput>;
  upsert?: Maybe<LanguageUpsertWithoutTranslationsInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface LiteralCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  translations: TranslationCreateOneWithoutLiteralInput;
  literal: String;
  as_in: String;
}

export interface LanguageUpdateWithoutTranslationsDataInput {
  name?: Maybe<String>;
  iso?: Maybe<String>;
  code?: Maybe<String>;
  projects?: Maybe<ProjectUpdateManyWithoutLanguagesInput>;
  users?: Maybe<UserUpdateManyWithoutLanguagesInput>;
}

export interface TranslationCreateWithoutLiteralInput {
  id?: Maybe<ID_Input>;
  language: LanguageCreateOneWithoutTranslationsInput;
  project: ProjectCreateOneWithoutTranslationsInput;
  translation: String;
}

export interface LanguageUpsertWithoutTranslationsInput {
  update: LanguageUpdateWithoutTranslationsDataInput;
  create: LanguageCreateWithoutTranslationsInput;
}

export interface ProjectCreateWithoutTranslationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  users?: Maybe<UserCreateManyWithoutProjectsInput>;
  languages?: Maybe<LanguageCreateManyWithoutProjectsInput>;
  literals?: Maybe<LiteralCreateManyWithoutProjectInput>;
}

export interface TranslationUpsertWithWhereUniqueWithoutProjectInput {
  where: TranslationWhereUniqueInput;
  update: TranslationUpdateWithoutProjectDataInput;
  create: TranslationCreateWithoutProjectInput;
}

export interface ProjectUpdateManyWithoutLanguagesInput {
  create?: Maybe<
    ProjectCreateWithoutLanguagesInput[] | ProjectCreateWithoutLanguagesInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutLanguagesInput[]
    | ProjectUpdateWithWhereUniqueWithoutLanguagesInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutLanguagesInput[]
    | ProjectUpsertWithWhereUniqueWithoutLanguagesInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface TranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  translation?: Maybe<String>;
  translation_not?: Maybe<String>;
  translation_in?: Maybe<String[] | String>;
  translation_not_in?: Maybe<String[] | String>;
  translation_lt?: Maybe<String>;
  translation_lte?: Maybe<String>;
  translation_gt?: Maybe<String>;
  translation_gte?: Maybe<String>;
  translation_contains?: Maybe<String>;
  translation_not_contains?: Maybe<String>;
  translation_starts_with?: Maybe<String>;
  translation_not_starts_with?: Maybe<String>;
  translation_ends_with?: Maybe<String>;
  translation_not_ends_with?: Maybe<String>;
  AND?: Maybe<TranslationScalarWhereInput[] | TranslationScalarWhereInput>;
  OR?: Maybe<TranslationScalarWhereInput[] | TranslationScalarWhereInput>;
  NOT?: Maybe<TranslationScalarWhereInput[] | TranslationScalarWhereInput>;
}

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  languages_every?: Maybe<LanguageWhereInput>;
  languages_some?: Maybe<LanguageWhereInput>;
  languages_none?: Maybe<LanguageWhereInput>;
  translations_every?: Maybe<TranslationWhereInput>;
  translations_some?: Maybe<TranslationWhereInput>;
  translations_none?: Maybe<TranslationWhereInput>;
  literals_every?: Maybe<LiteralWhereInput>;
  literals_some?: Maybe<LiteralWhereInput>;
  literals_none?: Maybe<LiteralWhereInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface TranslationUpdateManyWithWhereNestedInput {
  where: TranslationScalarWhereInput;
  data: TranslationUpdateManyDataInput;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
  OR?: Maybe<LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput>;
  NOT?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
}

export interface TranslationUpdateManyDataInput {
  translation?: Maybe<String>;
}

export type LiteralWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LiteralUpdateManyWithoutProjectInput {
  create?: Maybe<
    LiteralCreateWithoutProjectInput[] | LiteralCreateWithoutProjectInput
  >;
  delete?: Maybe<LiteralWhereUniqueInput[] | LiteralWhereUniqueInput>;
  connect?: Maybe<LiteralWhereUniqueInput[] | LiteralWhereUniqueInput>;
  set?: Maybe<LiteralWhereUniqueInput[] | LiteralWhereUniqueInput>;
  disconnect?: Maybe<LiteralWhereUniqueInput[] | LiteralWhereUniqueInput>;
  update?: Maybe<
    | LiteralUpdateWithWhereUniqueWithoutProjectInput[]
    | LiteralUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | LiteralUpsertWithWhereUniqueWithoutProjectInput[]
    | LiteralUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<LiteralScalarWhereInput[] | LiteralScalarWhereInput>;
  updateMany?: Maybe<
    | LiteralUpdateManyWithWhereNestedInput[]
    | LiteralUpdateManyWithWhereNestedInput
  >;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface LiteralUpdateWithWhereUniqueWithoutProjectInput {
  where: LiteralWhereUniqueInput;
  data: LiteralUpdateWithoutProjectDataInput;
}

export type TranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LiteralUpdateWithoutProjectDataInput {
  translations?: Maybe<TranslationUpdateOneRequiredWithoutLiteralInput>;
  literal?: Maybe<String>;
  as_in?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface TranslationUpdateOneRequiredWithoutLiteralInput {
  create?: Maybe<TranslationCreateWithoutLiteralInput>;
  update?: Maybe<TranslationUpdateWithoutLiteralDataInput>;
  upsert?: Maybe<TranslationUpsertWithoutLiteralInput>;
  connect?: Maybe<TranslationWhereUniqueInput>;
}

export interface UserCreateManyWithoutProjectsInput {
  create?: Maybe<
    UserCreateWithoutProjectsInput[] | UserCreateWithoutProjectsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface TranslationUpdateWithoutLiteralDataInput {
  language?: Maybe<LanguageUpdateOneRequiredWithoutTranslationsInput>;
  project?: Maybe<ProjectUpdateOneRequiredWithoutTranslationsInput>;
  translation?: Maybe<String>;
}

export interface TranslationCreateManyWithoutLanguageInput {
  create?: Maybe<
    | TranslationCreateWithoutLanguageInput[]
    | TranslationCreateWithoutLanguageInput
  >;
  connect?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
}

export interface ProjectUpdateOneRequiredWithoutTranslationsInput {
  create?: Maybe<ProjectCreateWithoutTranslationsInput>;
  update?: Maybe<ProjectUpdateWithoutTranslationsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutTranslationsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface ProjectCreateOneWithoutLiteralsInput {
  create?: Maybe<ProjectCreateWithoutLiteralsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface ProjectUpdateWithoutTranslationsDataInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutProjectsInput>;
  languages?: Maybe<LanguageUpdateManyWithoutProjectsInput>;
  literals?: Maybe<LiteralUpdateManyWithoutProjectInput>;
}

export interface UserCreateManyWithoutLanguagesInput {
  create?: Maybe<
    UserCreateWithoutLanguagesInput[] | UserCreateWithoutLanguagesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface ProjectUpsertWithoutTranslationsInput {
  update: ProjectUpdateWithoutTranslationsDataInput;
  create: ProjectCreateWithoutTranslationsInput;
}

export interface TranslationCreateManyWithoutProjectInput {
  create?: Maybe<
    | TranslationCreateWithoutProjectInput[]
    | TranslationCreateWithoutProjectInput
  >;
  connect?: Maybe<TranslationWhereUniqueInput[] | TranslationWhereUniqueInput>;
}

export interface TranslationUpsertWithoutLiteralInput {
  update: TranslationUpdateWithoutLiteralDataInput;
  create: TranslationCreateWithoutLiteralInput;
}

export interface LiteralCreateManyWithoutProjectInput {
  create?: Maybe<
    LiteralCreateWithoutProjectInput[] | LiteralCreateWithoutProjectInput
  >;
  connect?: Maybe<LiteralWhereUniqueInput[] | LiteralWhereUniqueInput>;
}

export interface LiteralUpsertWithWhereUniqueWithoutProjectInput {
  where: LiteralWhereUniqueInput;
  update: LiteralUpdateWithoutProjectDataInput;
  create: LiteralCreateWithoutProjectInput;
}

export interface ProjectCreateOneWithoutTranslationsInput {
  create?: Maybe<ProjectCreateWithoutTranslationsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface LiteralScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  literal?: Maybe<String>;
  literal_not?: Maybe<String>;
  literal_in?: Maybe<String[] | String>;
  literal_not_in?: Maybe<String[] | String>;
  literal_lt?: Maybe<String>;
  literal_lte?: Maybe<String>;
  literal_gt?: Maybe<String>;
  literal_gte?: Maybe<String>;
  literal_contains?: Maybe<String>;
  literal_not_contains?: Maybe<String>;
  literal_starts_with?: Maybe<String>;
  literal_not_starts_with?: Maybe<String>;
  literal_ends_with?: Maybe<String>;
  literal_not_ends_with?: Maybe<String>;
  as_in?: Maybe<String>;
  as_in_not?: Maybe<String>;
  as_in_in?: Maybe<String[] | String>;
  as_in_not_in?: Maybe<String[] | String>;
  as_in_lt?: Maybe<String>;
  as_in_lte?: Maybe<String>;
  as_in_gt?: Maybe<String>;
  as_in_gte?: Maybe<String>;
  as_in_contains?: Maybe<String>;
  as_in_not_contains?: Maybe<String>;
  as_in_starts_with?: Maybe<String>;
  as_in_not_starts_with?: Maybe<String>;
  as_in_ends_with?: Maybe<String>;
  as_in_not_ends_with?: Maybe<String>;
  AND?: Maybe<LiteralScalarWhereInput[] | LiteralScalarWhereInput>;
  OR?: Maybe<LiteralScalarWhereInput[] | LiteralScalarWhereInput>;
  NOT?: Maybe<LiteralScalarWhereInput[] | LiteralScalarWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface LiteralUpdateManyWithWhereNestedInput {
  where: LiteralScalarWhereInput;
  data: LiteralUpdateManyDataInput;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  admin?: Maybe<Boolean>;
  projects?: Maybe<ProjectUpdateManyWithoutUsersInput>;
  languages?: Maybe<LanguageUpdateManyWithoutUsersInput>;
}

export interface LiteralUpdateManyDataInput {
  literal?: Maybe<String>;
  as_in?: Maybe<String>;
}

export interface ProjectUpdateInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutProjectsInput>;
  languages?: Maybe<LanguageUpdateManyWithoutProjectsInput>;
  translations?: Maybe<TranslationUpdateManyWithoutProjectInput>;
  literals?: Maybe<LiteralUpdateManyWithoutProjectInput>;
}

export interface ProjectUpsertWithWhereUniqueWithoutUsersInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutUsersDataInput;
  create: ProjectCreateWithoutUsersInput;
}

export interface ProjectUpsertWithWhereUniqueWithoutLanguagesInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutLanguagesDataInput;
  create: ProjectCreateWithoutLanguagesInput;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface LanguageCreateManyWithoutUsersInput {
  create?: Maybe<
    LanguageCreateWithoutUsersInput[] | LanguageCreateWithoutUsersInput
  >;
  connect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface LanguageCreateManyWithoutProjectsInput {
  create?: Maybe<
    LanguageCreateWithoutProjectsInput[] | LanguageCreateWithoutProjectsInput
  >;
  connect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
}

export interface ProjectUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface LanguageCreateOneWithoutTranslationsInput {
  create?: Maybe<LanguageCreateWithoutTranslationsInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutLanguagesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLanguagesDataInput;
  create: UserCreateWithoutLanguagesInput;
}

export interface LanguageUpdateInput {
  name?: Maybe<String>;
  iso?: Maybe<String>;
  code?: Maybe<String>;
  projects?: Maybe<ProjectUpdateManyWithoutLanguagesInput>;
  users?: Maybe<UserUpdateManyWithoutLanguagesInput>;
  translations?: Maybe<TranslationUpdateManyWithoutLanguageInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  admin?: Maybe<Boolean>;
  admin_not?: Maybe<Boolean>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface TranslationUpdateInput {
  language?: Maybe<LanguageUpdateOneRequiredWithoutTranslationsInput>;
  literal?: Maybe<LiteralUpdateOneRequiredWithoutTranslationsInput>;
  project?: Maybe<ProjectUpdateOneRequiredWithoutTranslationsInput>;
  translation?: Maybe<String>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface ProjectCreateManyWithoutLanguagesInput {
  create?: Maybe<
    ProjectCreateWithoutLanguagesInput[] | ProjectCreateWithoutLanguagesInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  admin?: Maybe<Boolean>;
}

export interface ProjectCreateManyWithoutUsersInput {
  create?: Maybe<
    ProjectCreateWithoutUsersInput[] | ProjectCreateWithoutUsersInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface LanguageUpdateManyDataInput {
  name?: Maybe<String>;
  iso?: Maybe<String>;
  code?: Maybe<String>;
}

export interface LanguageUpdateManyWithWhereNestedInput {
  where: LanguageScalarWhereInput;
  data: LanguageUpdateManyDataInput;
}

export interface LanguageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  iso?: Maybe<String>;
  iso_not?: Maybe<String>;
  iso_in?: Maybe<String[] | String>;
  iso_not_in?: Maybe<String[] | String>;
  iso_lt?: Maybe<String>;
  iso_lte?: Maybe<String>;
  iso_gt?: Maybe<String>;
  iso_gte?: Maybe<String>;
  iso_contains?: Maybe<String>;
  iso_not_contains?: Maybe<String>;
  iso_starts_with?: Maybe<String>;
  iso_not_starts_with?: Maybe<String>;
  iso_ends_with?: Maybe<String>;
  iso_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  AND?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  OR?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  NOT?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
}

export interface LanguageUpsertWithWhereUniqueWithoutProjectsInput {
  where: LanguageWhereUniqueInput;
  update: LanguageUpdateWithoutProjectsDataInput;
  create: LanguageCreateWithoutProjectsInput;
}

export interface TranslationCreateOneWithoutLiteralInput {
  create?: Maybe<TranslationCreateWithoutLiteralInput>;
  connect?: Maybe<TranslationWhereUniqueInput>;
}

export interface LiteralCreateOneWithoutTranslationsInput {
  create?: Maybe<LiteralCreateWithoutTranslationsInput>;
  connect?: Maybe<LiteralWhereUniqueInput>;
}

export interface LiteralUpdateInput {
  project?: Maybe<ProjectUpdateOneRequiredWithoutLiteralsInput>;
  translations?: Maybe<TranslationUpdateOneRequiredWithoutLiteralInput>;
  literal?: Maybe<String>;
  as_in?: Maybe<String>;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  admin: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  admin: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  admin: () => Promise<AsyncIterator<Boolean>>;
}

export interface LanguageEdge {
  node: Language;
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Project {
  id: ID_Output;
  name: String;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = FragmentableArray<Language>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  translations: <T = FragmentableArray<Translation>>(args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  literals: <T = FragmentableArray<Literal>>(args?: {
    where?: LiteralWhereInput;
    orderBy?: LiteralOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = Promise<AsyncIterator<LanguageSubscription>>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  translations: <T = Promise<AsyncIterator<TranslationSubscription>>>(args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  literals: <T = Promise<AsyncIterator<LiteralSubscription>>>(args?: {
    where?: LiteralWhereInput;
    orderBy?: LiteralOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = FragmentableArray<Language>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  translations: <T = FragmentableArray<Translation>>(args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  literals: <T = FragmentableArray<Literal>>(args?: {
    where?: LiteralWhereInput;
    orderBy?: LiteralOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranslationSubscriptionPayload {
  mutation: MutationType;
  node: Translation;
  updatedFields: String[];
  previousValues: TranslationPreviousValues;
}

export interface TranslationSubscriptionPayloadPromise
  extends Promise<TranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TranslationPreviousValuesPromise>() => T;
}

export interface TranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TranslationPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  admin: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  admin: () => Promise<Boolean>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = FragmentableArray<Language>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  admin: () => Promise<AsyncIterator<Boolean>>;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = Promise<AsyncIterator<LanguageSubscription>>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  admin: () => Promise<Boolean>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = FragmentableArray<Language>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface LanguageConnection {
  pageInfo: PageInfo;
  edges: LanguageEdge[];
}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface TranslationPreviousValues {
  id: ID_Output;
  translation: String;
}

export interface TranslationPreviousValuesPromise
  extends Promise<TranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  translation: () => Promise<String>;
}

export interface TranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<TranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  translation: () => Promise<AsyncIterator<String>>;
}

export interface TranslationEdge {
  node: Translation;
  cursor: String;
}

export interface TranslationEdgePromise
  extends Promise<TranslationEdge>,
    Fragmentable {
  node: <T = TranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TranslationEdgeSubscription
  extends Promise<AsyncIterator<TranslationEdge>>,
    Fragmentable {
  node: <T = TranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  node: Language;
  updatedFields: String[];
  previousValues: LanguagePreviousValues;
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LanguagePreviousValues {
  id: ID_Output;
  name: String;
  iso: String;
  code: String;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  iso: () => Promise<String>;
  code: () => Promise<String>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  iso: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface Language {
  id: ID_Output;
  name: String;
  iso: String;
  code: String;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  iso: () => Promise<String>;
  code: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  translations: <T = FragmentableArray<Translation>>(args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  iso: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  translations: <T = Promise<AsyncIterator<TranslationSubscription>>>(args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LanguageNullablePromise
  extends Promise<Language | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  iso: () => Promise<String>;
  code: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  translations: <T = FragmentableArray<Translation>>(args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LiteralEdge {
  node: Literal;
  cursor: String;
}

export interface LiteralEdgePromise extends Promise<LiteralEdge>, Fragmentable {
  node: <T = LiteralPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LiteralEdgeSubscription
  extends Promise<AsyncIterator<LiteralEdge>>,
    Fragmentable {
  node: <T = LiteralSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LiteralSubscriptionPayload {
  mutation: MutationType;
  node: Literal;
  updatedFields: String[];
  previousValues: LiteralPreviousValues;
}

export interface LiteralSubscriptionPayloadPromise
  extends Promise<LiteralSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LiteralPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LiteralPreviousValuesPromise>() => T;
}

export interface LiteralSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LiteralSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LiteralSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LiteralPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LiteralPreviousValues {
  id: ID_Output;
  literal: String;
  as_in: String;
}

export interface LiteralPreviousValuesPromise
  extends Promise<LiteralPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  literal: () => Promise<String>;
  as_in: () => Promise<String>;
}

export interface LiteralPreviousValuesSubscription
  extends Promise<AsyncIterator<LiteralPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  literal: () => Promise<AsyncIterator<String>>;
  as_in: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTranslation {
  count: Int;
}

export interface AggregateTranslationPromise
  extends Promise<AggregateTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTranslationSubscription
  extends Promise<AsyncIterator<AggregateTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Translation {
  id: ID_Output;
  translation: String;
}

export interface TranslationPromise extends Promise<Translation>, Fragmentable {
  id: () => Promise<ID_Output>;
  language: <T = LanguagePromise>() => T;
  literal: <T = LiteralPromise>() => T;
  project: <T = ProjectPromise>() => T;
  translation: () => Promise<String>;
}

export interface TranslationSubscription
  extends Promise<AsyncIterator<Translation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  language: <T = LanguageSubscription>() => T;
  literal: <T = LiteralSubscription>() => T;
  project: <T = ProjectSubscription>() => T;
  translation: () => Promise<AsyncIterator<String>>;
}

export interface TranslationNullablePromise
  extends Promise<Translation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  language: <T = LanguagePromise>() => T;
  literal: <T = LiteralPromise>() => T;
  project: <T = ProjectPromise>() => T;
  translation: () => Promise<String>;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface Literal {
  id: ID_Output;
  literal: String;
  as_in: String;
}

export interface LiteralPromise extends Promise<Literal>, Fragmentable {
  id: () => Promise<ID_Output>;
  project: <T = ProjectPromise>() => T;
  translations: <T = TranslationPromise>() => T;
  literal: () => Promise<String>;
  as_in: () => Promise<String>;
}

export interface LiteralSubscription
  extends Promise<AsyncIterator<Literal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project: <T = ProjectSubscription>() => T;
  translations: <T = TranslationSubscription>() => T;
  literal: () => Promise<AsyncIterator<String>>;
  as_in: () => Promise<AsyncIterator<String>>;
}

export interface LiteralNullablePromise
  extends Promise<Literal | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project: <T = ProjectPromise>() => T;
  translations: <T = TranslationPromise>() => T;
  literal: () => Promise<String>;
  as_in: () => Promise<String>;
}

export interface AggregateLiteral {
  count: Int;
}

export interface AggregateLiteralPromise
  extends Promise<AggregateLiteral>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLiteralSubscription
  extends Promise<AsyncIterator<AggregateLiteral>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranslationConnection {
  pageInfo: PageInfo;
  edges: TranslationEdge[];
}

export interface TranslationConnectionPromise
  extends Promise<TranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TranslationEdge>>() => T;
  aggregate: <T = AggregateTranslationPromise>() => T;
}

export interface TranslationConnectionSubscription
  extends Promise<AsyncIterator<TranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTranslationSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface LiteralConnection {
  pageInfo: PageInfo;
  edges: LiteralEdge[];
}

export interface LiteralConnectionPromise
  extends Promise<LiteralConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LiteralEdge>>() => T;
  aggregate: <T = AggregateLiteralPromise>() => T;
}

export interface LiteralConnectionSubscription
  extends Promise<AsyncIterator<LiteralConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LiteralEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLiteralSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Translation",
    embedded: false
  },
  {
    name: "Literal",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
